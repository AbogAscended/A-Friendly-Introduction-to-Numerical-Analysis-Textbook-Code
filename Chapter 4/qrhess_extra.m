function [lambda, v] = qrhess ( A, TOL, Nmax )[row col] = size ( A );if ( row ~= col )   disp ( 'matrix must be square' );   return;end;n = row;c = zeros ( 1, n );s = zeros ( 1, n );shift = 0;togo = n;v = eye(n);for its = 1 : Nmax    if ( togo == 1 )	   lambda(1) = A(1,1) + shift;	   disp ( its );	   if ( nargout >=2 ) v = getvects ( n, lambda, A, v); end;	   return;	end;	    trace = A(togo-1,togo-1) + A(togo,togo);	det   = A(togo-1,togo-1)*A(togo,togo) - A(togo,togo-1)*A(togo-1,togo);	disc  = sqrt ( trace*trace - 4*det );	mu1 = ( (1/2) * ( trace + disc ) );	mu2 = ( (1/2) * ( trace - disc ) );	if ( abs ( mu1 - A(togo,togo) ) < abs ( mu2 - A(togo,togo) ) )	   s = mu1;	else	   s = mu2;	end;	    shift = shift + s;	for i = 1:togo 	    A(i,i) = A(i,i) - s;	end;	    for i = 2:togo        j = i-1;	    r = sqrt ( A(j,j)^2 + A(i,j)^2 );		if ( A(i,j) == 0 )		   c(i) = 1; s(i) = 0;		else	       c(i) = A(j,j) / r;	       s(i) = A(i,j) / r;		end;	    temp1 = c(i)*A(j,:) + s(i)*A(i,:);	    temp2 = -s(i)*A(j,:) + c(i)*A(i,:);	    A(j,:) = temp1;	    A(i,:) = temp2;    end;	for i = 2 : togo	    col1 = A(:,i-1) * c(i) + A(:,i) * s(i);		A(:,i) = -s(i) * A(:,i-1) + c(i) * A(:,i);		A(:,i-1) = col1;	end;	if ( nargout >= 2 )	   for i = 2 : togo	       col1 = v(:,i-1) * c(i) + v(:,i) * s(i);		   v(:,i) = -s(i) * v(:,i-1) + c(i) * v(:,i);		   v(:,i-1) = col1;	   end;	end;	if ( abs(A(togo,togo-1)) < TOL )	   lambda(togo) = A(togo,togo) + shift;	   togo = togo - 1;	end;end;	function v = getvects ( n, l, T, Q )for j = 1 : n    T(j,j) = l(j);end;for j = 2 : n    for i = 1 : j- 1	    z = -T(i,j) / ( T(i,i) - T(j,j) );		for k = j+1 : n		    T(i,k) = T(i,k) - z * T(j,k);		end;		for k = 1 : n		    Q(k,j) = Q(k,i) * z + Q(k,j);	    end;	end;end;for j = 1 : n    maxindex = min ( find ( max ( abs ( Q(:,j) ) ) == abs ( Q(:,j) ) ) );    v(:,j) = Q(:,j) / Q(maxindex,j);end;		