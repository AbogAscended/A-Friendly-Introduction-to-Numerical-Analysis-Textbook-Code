function [lambda, vects] = wielandt ( A, num_pairs, TOL, Nmax )%WIELANDT       apply Wielandt deflation to an arbitrary matrix to %               approximate a specified number of eigenpairs associated%               with the either largest or the smallest eigenvalues of %               the matrix - the routine POWER_METHOD is used to approximate%               eigenpairs associated with the largest eigenvalues, the%               routine INV_POWER is used to approximate eigenpairs%               associated with the smallest eigenvalues%%     calling sequences:%             [lambda, vects] = wielandt ( A, num_pairs, TOL, Nmax )%             lambda = wielandt ( A, num_pairs, TOL, Nmax )%             wielandt ( A, num_pairs, TOL, Nmax )%%     inputs:%             A       square symmetric matrix whose eigenpairs are to be %                     approximated%             num_pairs%                     number of eigenpairs to approximate%                     if num_pairs > 0 then approximate largest eigenvalues%                     if num_pairs < 0 then approximate smallest eigenvalues%             TOL     absolute error convergence tolerance applied during%                     each call to either POWER_METHOD or INV_POWER%                     (convergence is measured in terms of the maximum%                     norm of the difference between successive terms %                     in the eigenvector seqeunce)%             Nmax    maximum number of iterations to be performed during%                     each call to either POWER_METHOD or INV_POWER%%     outputs:%             lambda  vector containing the largest/smallest 'num_pairs' %                     eigenvalues of the matrix A%             vects   matrix containing eigenvectors corresponding to the %                     entries in the output vector 'lambda'%                     - the i-th column of this matrix is an eigenvector,%                       normalized to unit length in the maximum norm,%                       corresponding to the i-th entry in the vector%                       'lambda'%%     dependencies:%             this routine makes use of the routines POWER_METHOD and%             INV_POWER%%     NOTE:%             if the maximum number of iterations is exceeded during any%             call to either POWER_METHOD or INV_POWER, a message to this %             effect will be displayed %[r c] = size ( A );if ( r ~= c )   disp ( 'wielandt error: matrix must be square' );   return;end;n = r;if ( num_pairs < 0 )   num_pairs = abs(num_pairs);   small = 1;else   small = 0;end;l = zeros ( 1, num_pairs );v = zeros ( n, num_pairs );j = zeros ( 1, num_pairs );x = zeros ( num_pairs, n );if ( small == 0 )   [l(1) v(:,1)] = power_method ( A, rand(n,1), TOL, Nmax );else   [l(1) v(:,1)] = inv_power ( A, 0, rand(1,n), TOL, Nmax );end;for i = 2:num_pairs    j(i) = min ( find ( abs(v(:,i-1))  == max(abs(v(:,i-1))) ) );	x(i,1:n+2-i) = A(j(i),:);    A = wd ( A, n+2-i, j(i), v(:,i-1) );	if ( small == 0 )	   [l(i) v(1:n-i+1,i)] = power_method ( A, rand(n-i+1,1), TOL, Nmax );	else	   [l(i) v(1:n-i+1,i)] = inv_power ( A, 0, rand(1,n-i+1), TOL, Nmax );	end;end;for i=num_pairs:-1:2    for k=i:-1:2	    temp = [v(1:j(k)-1, i); 0; v(j(k):n-k+1, i)];		v(1:n-k+2,i) = (l(i) - l(k-1))*temp +(x(k,1:n+2-k)*temp)*v(1:n-k+2,k-1)/v(j(k),k-1);	end;    p = min ( find ( abs(v(:,i))  == max(abs(v(:,i))) ) );    v(:,i) = v(:,i) / v(p,i);end;lambda = l;vects = v;return;function B = wd ( A, n, j, v )temp = ( v / v(j) ) * A(j,:);B = [A(1:j-1,1:j-1)-temp(1:j-1,1:j-1) A(1:j-1,j+1:n) - temp(1:j-1,j+1:n); ...     A(j+1:n,1:j-1)-temp(j+1:n,1:j-1) A(j+1:n,j+1:n) - temp(j+1:n,j+1:n)];return;