function y = adapt_gq3 ( f, a, b, TOL )%ADAPT_GQ3     approximate the definite integral of an arbitrary function%              to within a specified error tolerance using adaptive %              quadrature based on the three-point Gaussian quadrature rule%%     calling sequences:%             y = adapt_gq3 ( 'f', a, b, TOL )%             adapt_gq3 ( 'f', a, b, TOL )%%     inputs:%             f       string containing name of m-file defining integrand%             a       lower limit of integration%             b       upper limit of integration%             TOL     absolute error convergence tolerance%%     output:%             y       approximate value of the definite integral of f(x)%                     over the interval a < x < b%%     NOTE:%             if ADAPT_GQ3 is called with no output arguments, the  %             approximate value of the definite integral of f(x) over %             the interval a < x < b will be displayed, together with%             the estimate for the error in the approximation and the %             total number of function evaluations used%h2 = ( b - a ) / 2;fm = feval ( f, a + h2 - sqrt(3/5)*h2 );fc = feval ( f, a + h2 );fp = feval ( f, a + h2 + sqrt(3/5)*h2 );sab = h2 * ( 5*fm + 8*fc + 5*fp ) / 9;[approx eest nfunc] = as ( sab, f, a, b, TOL );if ( nargout == 0 )   s = sprintf ( '\t\t approximate value of integral: \t %.12f \n', approx );   s = sprintf ( '%s \t\t error estimate: \t\t\t\t\t %.4e \n', s, eest );   s = sprintf ( '%s \t\t number of function evaluations: \t %d \n', s, nfunc+3 );   disp ( s )else   y = approx; end;returnfunction [app, est, nf] = as ( sab, f, a, b, TOL )h2 = ( b - a ) / 4;fml = feval ( f, a + h2 - sqrt(3/5)*h2 );fcl = feval ( f, a + h2 );fpl = feval ( f, a + h2 + sqrt(3/5)*h2 );fmr = feval ( f, b - h2 - sqrt(3/5)*h2 );fcr = feval ( f, b - h2 );fpr = feval ( f, b - h2 + sqrt(3/5)*h2 );sac = h2 * ( 5*fml + 8*fcl + 5*fpl ) / 9;scb = h2 * ( 5*fmr + 8*fcr + 5*fpr ) / 9;errest = abs ( sab - sac - scb );if ( errest < (42.0*TOL) )   app = sac+scb;   est = errest / 42.0;   nf = 6;   return;else   [a1 e1 n1] = as ( sac, f, a, a+2*h2, TOL/2.0 );   [a2 e2 n2] = as ( scb, f, a+2*h2, b, TOL/2.0 );   app = a1 + a2;   est = e1 + e2;   nf = n1 + n2 + 6;   return;end;