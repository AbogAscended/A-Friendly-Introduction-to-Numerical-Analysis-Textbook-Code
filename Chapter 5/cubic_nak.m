function csn = cubic_nak ( xi, fi )%CUBIC_NAK     compute the cubic spline interpolant, subject to %              "not-a-knot" boundary conditions, associated with a %              given set of interpolating points and function values%%     calling sequences:%             csn = cubic_nak ( xi, fi )%             cubic_nak ( xi, fi )%%     inputs:%             xi      vector containing the interpolating points%                     (must be sorted in ascending order)%             fi      vector containing function values%                     the i-th entry in this vector is the function%                     value associated with the i-th entry in the 'xi'%                     vector%%     output:%             csn     five column matrix containing the information which%                     defines the "not-a-knot" cubic spline interpolant%                     - first column: interpolating points%                     - second column: function values%                     - third column: coefficients of linear terms%                     - fourth column: coefficients of quadratic terms%                     - fifth column: coefficients of cubic terms%%     NOTE:%             to evaluate the "not-a-knot" cubic spline interpolant apply%             the routine SPLINE_EVAL to the output of this routine %n = length ( xi );m = length ( fi );if ( n ~= m )   disp ( 'number of ordinates and number of function values must be equal' )   returnendfor i = 1 : n-1    hi(i) = xi(i+1) - xi(i);endfor i = 1 : n-2    dd(i) = 2.0 * ( hi(i) + hi(i+1) );	ri(i) = (3.0/hi(i+1))*(fi(i+2)-fi(i+1))-(3.0/hi(i))*(fi(i+1)-fi(i));enddd(1)   = dd(1)   + hi(1) + hi(1)^2 / hi(2);dd(n-2) = dd(n-2) + hi(n-1) + hi(n-1)^2 / hi(n-2);du = hi(2:n-2);dl = du;du(1) = du(1) - hi(1)^2 / hi(2);dl(n-3) = dl(n-3) - hi(n-1)^2 / hi(n-2);dl;dd;du;ri;temp = tridiagonal ( dl, dd, du, ri );c = zeros ( n,1 );d = c;   b = c;c(2:n-1) = temp;c(1) = ( 1 + hi(1) / hi(2) ) * c(2) - hi(1) / hi(2) * c(3);c(n) = ( 1 + hi(n-1) / hi(n-2) ) * c(n-1) - hi(n-1) / hi(n-2) * c(n-2);for i = 1 : n-1    d(i) = (c(i+1)-c(i))/(3.0*hi(i));	b(i) = (fi(i+1)-fi(i))/hi(i) - hi(i)*(c(i+1)+2.0*c(i))/3.0;endif ( nargout == 0 )   disp ( [ xi' fi' b c d ] )else   csn = [ xi' fi' b c d ];end