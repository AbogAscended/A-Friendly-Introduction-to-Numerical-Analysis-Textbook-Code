function [ti, wi, count] = vs_ab2trap ( RHS, t0, x0, tf, parms )neqn = length ( x0 );hmin = parms(1);hmax = parms(2);TOL  = parms(3);ti(1) = t0;wi(1:neqn, 1) = x0';count = 0;h = hmax;oldf = zeros(1,neqn);done = 0;last = 0;flag = 1;ts = 1;while ( done == 0 )%%  generate starting values using classical Huen method%  remember to save function values%    if ( flag == 1 )           oldf = feval ( RHS, t0, x0 );           xtilde = x0 + (2*h/3) * oldf;           x0 = x0 + (h/4) * ( oldf + 3 * feval ( RHS, t0+2*h/3, xtilde ) );	       t0 = t0 + h;           ti(ts+1) = t0;           wi(1:neqn, ts+1) = x0';       count = count + 2;	   ts = ts + 1;    end;%%  continue time stepping with 2nd order Adams-Bashforth Predictor / %  Trapezoidal Corrector%    fnew = feval ( RHS, t0, x0 );    xtilde = x0 + (h/2) * ( 3*fnew - oldf );	fnew1 = feval ( RHS, t0+h, xtilde );	x0 = x0 + (h/2) * ( fnew1 + fnew );		R = max ( abs ( x0 - xtilde ) / ( 6 * h ) );	q = ( TOL / (2*R) ) ^ (1/2);	count = count + 2; 		if ( R < TOL )	   ts = ts + 1;	   t0 = t0 + h;	   ti(ts) = t0;       wi(1:neqn, ts) = x0';	   oldf = fnew;	   if ( last == 1 ) 	      done = 1;	   elseif ( R < 0.1 * TOL | ( t0 + h ) > tf )	      if ( R < 0.1 * TOL ) h = min ( hmax, min ( q, 4.0 ) * h );  end;		  if ( ( t0 + 2*h ) > tf ) h = ( tf - t0 ) / 2;  last = 1;  end;	      flag = 1; 	   else	      flag = 0;	   end;	else		h = max ( q, 0.1 ) * h;        if ( h < hmin )	       disp ( 'Solution requires step size smaller than minimum' );	       return;	    end;		if ( flag == 1 )		   ts = ts - 1;		end;		t0 = ti(ts);		x0 = wi(1:neqn, ts)';		flag = 1;		if ( ( t0 + 2*h ) > tf ) 		   h = ( tf - t0 ) / 2;  		   last = 1;         else		   last = 0;		end;	end;end;