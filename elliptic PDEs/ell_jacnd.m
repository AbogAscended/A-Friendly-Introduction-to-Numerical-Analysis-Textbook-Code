function [w, x, y, rn] = ell_jacnd ( a, b, N, c, d, M, f, g, alpha, pqr, TOL, Nmax )%ELL_JACND    approximate the solution of the elliptic partial differential%             equation%%                    u_xx + u_yy = f(x,y),%%             defined over a rectangular domain, subject to %%                    dirichlet boundary conditions along left and bottom%                              edges of domain%                    robin boundary condition along right edge of domain%                    neumann boundary condition along top edge of domain%%             using the finite difference method with Jacobi relaxation%%%     calling sequences:%             [w, x, y] = ell_jacnd ( a, b, N, c, d, M, f, g, alpha, pqr, TOL, Nmax )%             [w, x, y, rn] = ell_jacnd ( a, b, N, c, d, M, f, g, alpha, pqr, TOL, Nmax )%%     inputs:%             a       left endpoint of problem domain in x-direction%             b       right endpoint of problem domain in x-direction%             N       number of uniformly-sized subintervals in x-direction%             c       lower endpoint of problem domain in y-direction%             d       upper endpoint of problem domain in y-direction%             M       number of uniformly-sized subintervals in y-direction%             f       string containing name of m-file defining the %                     right-hand side of the differential equation; %                     function should take two inputs and return a single%                     output value%             g       string containing name of m-file defining the %                     Dirichlet boundary conditions; function should take %                     two inputs and return a single output value%             alpha   string containing name of m-file defining the%                     Neumann boundary condition; function should take%                     a single input and return a single output%             pqr     string containing name of m-file defining the%                     coefficients in the Robin boundary condition;%                     function should take a single output and return%                     a three component vector containing the values of%                     the three coefficient functions%             TOL     convergence tolerance for Jacobi relaxation; %                     applied to the maximum norm of the difference between%                     successive approximations%             Nmax    maximum number of iterations of Jacobi relaxation%                     to be performed to achieve convergence%%     output:%             w       matrix of dimension (N+1) x (M+1) containing the %                     approximate values of the solution of the partial%                     differential equation%             x       vector of length N+1 containing the x-values of the%                     computational grid%             y       vector of length M+1 containing the y-values of the%                     computational grid%             rn      vector containing the residual norm associated with%                     each iteration of Jacobi relaxation%%     NOTE:%             It is assumed that the values of N and M have been specified%             so that (b-a)/N = (d-c)/M%x = linspace ( a, b, N+1 );y = linspace ( c, d, M+1 );h = (b-a)/N;hsq = h*h;if ( nargout > 3 ) rn = zeros ( 1, Nmax ); end;%%   load Dirichlet boundary values along left and bottom edges%   of solution matrix%wold = zeros ( N+1, M+1 );for i = 1 : N+1    wold(i,  1) = feval ( g, x(i), y(1) );end;for j = 2 : M+1    wold(1,  j) = feval ( g, x(1), y(j) );end;% %   load h^2 times value of right-hand side function into a%   matrix for lookup%fmat = zeros ( N+1, M+1 );for i = 2 : N+1    for j = 2 : M+1	    fmat(i,j) = hsq * feval ( f, x(i), y(j) );	end;end;%%   perform relaxation sweeps%for its = 1 : Nmax    res_norm = 0;	for j = 2 : M	    for i = 2 : N		    new = 0.25 * ( wold(i-1,j) + wold(i+1,j) + wold(i,j-1) + wold(i,j+1) - fmat(i,j) );            res = wold(i,j) - new;			wnew(i,j) = new;			if ( abs ( res ) > res_norm ) res_norm = abs(res); end;		end;	    [p q r] = feval ( pqr, y(j) );		new = ( 2*wold(N,j) + wold(N+1,j-1) + wold(N+1,j+1) - fmat(N+1,j) + 2*h*r/p ) / (4 + 2*h*q/p);        res = wold(N+1,j) - new;	    wnew(N+1,j) = new;		if ( abs ( res ) > res_norm ) res_norm = abs(res); end;	end;	for i = 2 : N		new = 0.25 * ( wold(i-1,M+1) + wold(i+1,M+1) + 2*wold(i,M) - fmat(i,M+1) + 2*h*feval ( alpha, x(i) ) );        res = wold(i,M+1) - new;		wnew(i,M+1) = new;		if ( abs ( res ) > res_norm ) res_norm = abs(res); end;	end;		[p q r] = feval ( pqr, y(M+1) );	new = ( 2*wold(N,M+1) + 2*wold(N+1,M) - fmat(N+1,M+1) + 2*h*r/p + 2*h*feval ( alpha, x(N+1) ) ) / (4 + 2*h*q/p);    res = wold(N+1,M+1) - new;	wnew(N+1,M+1) = new;	if ( abs ( res ) > res_norm ) res_norm = abs(res); end;		wold(2:N+1,2:M+1) = wnew(2:N+1,2:M+1);	if ( nargout > 3 ) rn(its) = res_norm; end;		if ( res_norm < TOL ) w = wold; disp(its); return; end;end; w = wold;	   