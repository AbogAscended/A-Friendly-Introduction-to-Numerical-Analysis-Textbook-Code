function w = vcycle3 ( N, num_cycle, num_sweep1, num_sweep2, TOL, win )x = linspace ( 0, 60, N+1 );y = linspace ( 0, 60, N+1 );h = 60/N;hsq = h*h;num_grids = log(N)/log(2);wpv = 0;for gn = 1 : num_grids    Ngi = N / 2^(gn-1);    grid(gn).N = Ngi;	grid(gn).f = zeros ( Ngi+1, Ngi+1 );	grid(gn).u = zeros ( Ngi+1, Ngi+1 );	wpv = wpv + 4^(1-gn);end;wpv = wpv * (num_sweep1 + num_sweep2 );for i = 2:N     for j = 2:N 	    grid(1).f(i,j) = hsq * ( win(i,j) ); 	end; end;for i = 1 : N+1    grid(1).u(i,1)   = 0;	grid(1).u(i,N+1) = 0;end;for j = 2 : N    grid(1).u(1,j)   = 0;	grid(1).u(N+1,j) = 0;end;r = zeros ( N+1, N+1 );total_work = 0;for cycles = 1 : num_cycle    for gn = 1 : num_grids-1;	    N = grid(gn).N;		h = 1/N;		hsq = h*h;        for sweeps = 1 : num_sweep1            for j = 2 : N	            for i = 2 : N			        r(i,j) = grid(gn).f(i,j) - ( grid(gn).u(i-1,j) + grid(gn).u(i+1,j) + grid(gn).u(i,j-1) + grid(gn).u(i,j+1) - 4*grid(gn).u(i,j) );			        grid(gn).u(i,j) = grid(gn).u(i,j) - r(i,j)/4;		        end;	        end;        end;        for i = 3 : 2 : N-1	        for j = 3 : 2 : N-1                grid(gn+1).f((i+1)/2, (j+1)/2) = 4 * ( grid(gn).f(i,j) - ( grid(gn).u(i-1,j) + grid(gn).u(i+1,j) + grid(gn).u(i,j-1) + grid(gn).u(i,j+1) - 4*grid(gn).u(i,j) ) );                grid(gn+1).u((i+1)/2, (j+1)/2) = 0;		    end;	    end;	end;		grid(num_grids).u(2,2) = 0.25 * ( -grid(num_grids).f(2,2) + grid(num_grids).u(1,2) + grid(num_grids).u(3,2) + grid(num_grids).u(2,1) + grid(num_grids).u(2,3) );	for gn = num_grids-1 : -1: 1	    N = grid(gn).N;		h = 1/N;		hsq = h*h;	    for i = 2 : N	        for j = 2 : N		        if ( mod(i+1,2) == 0 )			       if ( mod(j+1,2) == 0 )			          grid(gn).u(i,j) = grid(gn).u(i,j) + grid(gn+1).u((i+1)/2, (j+1)/2);			       else			          grid(gn).u(i,j) = grid(gn).u(i,j) + 0.5 * ( grid(gn+1).u((i+1)/2, j/2) + grid(gn+1).u((i+1)/2, (j+2)/2) );			       end;			    else			       if ( mod(j+1,2) == 0 )			          grid(gn).u(i,j) = grid(gn).u(i,j) + 0.5 * ( grid(gn+1).u(i/2, (j+1)/2) + grid(gn+1).u((i+2)/2, (j+1)/2) );			       else			          grid(gn).u(i,j) = grid(gn).u(i,j) + 0.25 * ( grid(gn+1).u(i/2, j/2) + grid(gn+1).u(i/2, (j+2)/2) + grid(gn+1).u((i+2)/2, j/2) + grid(gn+1).u((i+2)/2, (j+2)/2) );			       end;			    end;		    end;	    end;        for sweeps = 1 : num_sweep2		    rn  = 0;            for j = 2 : N	            for i = 2 : N			        r(i,j) = grid(gn).f(i,j) - ( grid(gn).u(i-1,j) + grid(gn).u(i+1,j) + grid(gn).u(i,j-1) + grid(gn).u(i,j+1) - 4*grid(gn).u(i,j) );			        grid(gn).u(i,j) = grid(gn).u(i,j) - r(i,j)/4;		        end;	        end;				        if ( gn == 1 ) 			   rnorm = max ( max ( abs ( r ) ) );			   if ( cycles == 1 )			      disp ( sprintf ( ' %d \t %.3e \n', cycles, rnorm/4 ) );			   else			      cpv = rnorm / rsave;				  disp ( sprintf ( ' %d \t %.3e \t %.6f \t %.6f \n', cycles, rnorm/4, cpv, (cpv)^(1/wpv) ) );			   end;			   if ( rnorm < 4*TOL ) 			      w = grid(1).u;                  disp ( sprintf ( ' total number of work units used = %f \n', total_work+wpv ) );                  return; 			   end;			   rsave = rnorm; 			end;        end;    end;	total_work = total_work + wpv;end;