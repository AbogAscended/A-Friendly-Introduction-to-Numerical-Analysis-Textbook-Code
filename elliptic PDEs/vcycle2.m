function w = vcycle ( N, num_cycle, num_sweep1, num_sweep2, TOL, f, g )%VCYCLE       approximate the solution of the elliptic partial differential%             equation%%                    u_xx + u_yy = f(x,y),%%             defined over the unit square with Dirichlet conditions %             specified around the entire boundary using the finite%             difference method; the finite difference equations are%             solved using multigrid v-cycles with Gauss-Sediel%             relaxation%%%     calling sequences:%             w = vcycle ( N, num_cycle, num_sweep1, num_sweep2, TOL, f, g )%             vcycle ( N, num_cycle, num_sweep1, num_sweep2, TOL, f, g )%%     inputs:%             N       number of uniformly-sized subintervals in each direction%                     of the computational grid%             num_cycle%                     maximum number of v-cycles to perform to achieve%                     convergence%             num_sweep1%                     number of relaxation sweeps to perform on each%                     grid while working from the finest grid to the%                     coarsest grid%             num_sweep2%                     number of relaxation sweeps to perform on each%                     grid while working from the coarsest grid to the%                     finest grid%             TOL     convergence tolerance applied to residual norm%                     on finest grid%             f       string containing name of m-file defining the %                     right-hand side of the differential equation; %                     function should take two inputs and return a single%                     output value%             g       string containing name of m-file defining the %                     Dirichlet boundary conditions; function should take %                     two inputs and return a single output value%%     output:%             w       matrix of dimension (N+1) x (M+1) containing the %                     approximate values of the solution of the partial%                     differential equation%%     NOTE:  %             After each v-cycle, the cycle number, the residual norm%             on the finest grid, the convergence per v-cycle and the%             convergence per work unit are reported.%x = linspace ( 0, 1, N+1 );y = linspace ( 0, 1, N+1 );h = 1/N;hsq = h*h;%%   set up grid structure%num_grids = log(N)/log(2);wpv = 0;for gn = 1 : num_grids    Ngi = N / 2^(gn-1);    grid(gn).N = Ngi;	grid(gn).f = zeros ( Ngi+1, Ngi+1 );	grid(gn).u = zeros ( Ngi+1, Ngi+1 );	wpv = wpv + 4^(1-gn);end;wpv = wpv * (num_sweep1 + num_sweep2 );%%   load values from nonhomogeneous term into 'f' matrix on %   finest grid%for i = 2:N     for j = 2:N 	    grid(1).f(i,j) = hsq * feval ( f, x(i), y(j) ); 	end; end;%%   load Dirichlet boundary condition values along edge of%   solution matrix on finest grid%for i = 1 : N+1    grid(1).u(i,1)   = feval ( g, x(i), y(1) );	grid(1).u(i,N+1) = feval ( g, x(i), y(N+1) );end;for j = 2 : N    grid(1).u(1,j)   = feval ( g, x(1), y(j) );	grid(1).u(N+1,j) = feval ( g, x(N+1), y(j) );end;r = zeros ( N+1, N+1 );%%   perform v-cycles%total_work = 0;for cycles = 1 : num_cycle    for gn = 1 : num_grids-1;	    N = grid(gn).N;		h = 1/N;		hsq = h*h;        for sweeps = 1 : num_sweep1            for j = 2 : N	            for i = 2 : N			        r(i,j) = grid(gn).f(i,j) - ( grid(gn).u(i-1,j) + grid(gn).u(i+1,j) + grid(gn).u(i,j-1) + grid(gn).u(i,j+1) - 4*grid(gn).u(i,j) );			        grid(gn).u(i,j) = grid(gn).u(i,j) - r(i,j)/4;		        end;	        end;        end;        for i = 3 : 2 : N-1	        for j = 3 : 2 : N-1                grid(gn+1).f((i+1)/2, (j+1)/2) = 4 * ( grid(gn).f(i,j) - ( grid(gn).u(i-1,j) + grid(gn).u(i+1,j) + grid(gn).u(i,j-1) + grid(gn).u(i,j+1) - 4*grid(gn).u(i,j) ) );                grid(gn+1).u((i+1)/2, (j+1)/2) = 0;		    end;	    end;	end;		grid(num_grids).u(2,2) = 0.25 * ( -grid(num_grids).f(2,2) + grid(num_grids).u(1,2) + grid(num_grids).u(3,2) + grid(num_grids).u(2,1) + grid(num_grids).u(2,3) );	for gn = num_grids-1 : -1: 1	    N = grid(gn).N;		h = 1/N;		hsq = h*h;	    for i = 2 : N	        for j = 2 : N		        if ( mod(i+1,2) == 0 )			       if ( mod(j+1,2) == 0 )			          grid(gn).u(i,j) = grid(gn).u(i,j) + grid(gn+1).u((i+1)/2, (j+1)/2);			       else			          grid(gn).u(i,j) = grid(gn).u(i,j) + 0.5 * ( grid(gn+1).u((i+1)/2, j/2) + grid(gn+1).u((i+1)/2, (j+2)/2) );			       end;			    else			       if ( mod(j+1,2) == 0 )			          grid(gn).u(i,j) = grid(gn).u(i,j) + 0.5 * ( grid(gn+1).u(i/2, (j+1)/2) + grid(gn+1).u((i+2)/2, (j+1)/2) );			       else			          grid(gn).u(i,j) = grid(gn).u(i,j) + 0.25 * ( grid(gn+1).u(i/2, j/2) + grid(gn+1).u(i/2, (j+2)/2) + grid(gn+1).u((i+2)/2, j/2) + grid(gn+1).u((i+2)/2, (j+2)/2) );			       end;			    end;		    end;	    end;        for sweeps = 1 : num_sweep2		    rn  = 0;            for j = 2 : N	            for i = 2 : N			        r(i,j) = grid(gn).f(i,j) - ( grid(gn).u(i-1,j) + grid(gn).u(i+1,j) + grid(gn).u(i,j-1) + grid(gn).u(i,j+1) - 4*grid(gn).u(i,j) );			        grid(gn).u(i,j) = grid(gn).u(i,j) - r(i,j)/4;		        end;	        end;				        if ( gn == 1 ) 			   rnorm = max ( max ( abs ( r ) ) );			   if ( cycles == 1 )			      disp ( sprintf ( ' %d \t %.3e \n', cycles, rnorm/4 ) );			   else			      cpv = rnorm / rsave;				  disp ( sprintf ( ' %d \t %.3e \t %.6f \t %.6f \n', cycles, rnorm/4, cpv, (cpv)^(1/wpv) ) );			   end;			   if ( rnorm < 4*TOL ) 			      w = grid(1).u;                  disp ( sprintf ( ' total number of work units used = %f \n', total_work+wpv ) );                  return; 			   end;			   rsave = rnorm; 			end;        end;    end;	total_work = total_work + wpv;end;