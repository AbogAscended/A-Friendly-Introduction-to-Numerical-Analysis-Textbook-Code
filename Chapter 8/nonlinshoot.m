function u = nonlinshoot ( RHS, a, b, n, alpha, beta, TOL, Nmax, s )%NONLINSHOOT  approximate the solution of the nonlinear boundary value%             problem%%                   u'' = f ( x, u, u' )%                   alpha(1) u(a) + alpha(2) u'(a) = alpha(3)%                   beta(1)  u(b) + beta(2)  u'(b) = beta(3)%%             using the shooting method, with the solution of all %             initial value problems approximated using the classical%             4th-order Runge-Kutta method and the Secant method is%             used to solve the corresponding rootfinding problem%%%     calling sequences:%             u = nonlinshoot ( RHS, a, b, n, alpha, beta, TOL, Nmax, s )%             nonlinshoot ( RHS, a, b, n, alpha, beta, TOL, Nmax, s )%%     inputs:%             RHS     string containing name of m-file defining the %                     function f(x,u,u') on the right-hand side of the %                     differential equation; function should take three %                     inputs and return the single output value of f; %                     i.e., the m-file header should be of the form%                            f = coeff ( x, u, up )%             a       left endpoint of problem domain%             b       right endpoint of problem domain%             n       number of uniformly-sized steps to take in marching%                     from x = a to x = c%             alpha   three-component vector of the coefficients which%                     define the boundary condition at x = a%             beta    three-component vector of the coefficients which%                     define the boundary condition at x = b%             TOL     convergence tolerance for the Secant method; applied%                     to the maximum norm of the difference between%                     successive approximations%             Nmax    maximum number of iterations of the Secant method%                     to be performed to achieve convergence%             s       two-component vector containing the starting values%                     used by the Secant method%%     output:%             u       vector of length n+1 containing the approximate%                     values of the solution of the boundary value%                     problem at the locations x = linspace ( a, b, n+1 )%%     NOTE:%             if Newton's method does not converge within the allowed%             number of iterations, then the most recent approximation%             is returned in the vector u%u = zeros ( 2, n+1 );x = linspace ( a, b, n+1 );h = ( b - a ) / n;s0 = s(1);s1 = s(2);if ( alpha(2) == 0 )   u(:,1) = [alpha(3)/alpha(1); s0];elseif ( alpha(1) == 0 )   u(:,1) = [s0; alpha(3)/alpha(2)];else   u(:,1) = [(alpha(3)-s0*alpha(2))/alpha(1); s0];end;u = shootstep ( RHS, x, h, u, n );f0 = beta(3) - beta(1) * u(1,n+1) - beta(2) * u(2,n+1);if ( alpha(2) == 0 )   u(:,1) = [alpha(3)/alpha(1); s1];elseif ( alpha(1) == 0 )   u(:,1) = [s1; alpha(3)/alpha(2)];else   u(:,1) = [(alpha(3)-s1*alpha(2))/alpha(1); s1];end;u = shootstep ( RHS, x, h, u, n );f1 = beta(3) - beta(1) * u(1,n+1) - beta(2) * u(2,n+1);%%   apply the Secant method to solve the rootfinding problem%for i = 1 : Nmax    si = s1 - f1 * ( s1 - s0 ) / ( f1 - f0 );    if ( alpha(2) == 0 )       u(:,1) = [alpha(3)/alpha(1); si];    elseif ( alpha(1) == 0 )       u(:,1) = [si; alpha(3)/alpha(2)];    else       u(:,1) = [(alpha(3)-si*alpha(2))/alpha(1); si];    end;		u = shootstep ( RHS, x, h, u, n );    fi = beta(3) - beta(1) * u(1,n+1) - beta(2) * u(2,n+1);	if ( abs ( fi ) < TOL )	   return;	else	   s0 = s1;   s1 = si;	   f0 = f1;   f1 = fi;	end;end;function u = shootstep ( RHS, x, h, u, n ) for i = 1 : n    k1(1) = h * u(2,i);	k1(2) = h * feval ( RHS, x(i), u(1,i), u(2,i) );		k2(1) = h * ( u(2,i) + 0.5 * k1(2) );	k2(2) = h * feval ( RHS, x(i) + h/2, u(1,i) + 0.5 * k1(1), u(2,i) + 0.5 * k1(2) );		k3(1) = h * ( u(2,i) + 0.5 * k2(2) );	k3(2) = h * feval ( RHS, x(i) + h/2, u(1,i) + 0.5 * k2(1), u(2,i) + 0.5 * k2(2) );			k4(1) = h * ( u(2,i) + k3(2) );	k4(2) = h * feval ( RHS, x(i) + h, u(1,i) + k3(1), u(2,i) + k3(2) );		u(1,i+1) = u(1,i) + ( k1(1) + 2*k2(1) + 2*k3(1) + k4(1) ) / 6;	u(2,i+1) = u(2,i) + ( k1(2) + 2*k2(2) + 2*k3(2) + k4(2) ) / 6;end;