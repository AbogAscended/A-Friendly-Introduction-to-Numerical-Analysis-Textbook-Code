function w = nonlinfd ( coeff, a, b, n, alpha, beta, TOL, Nmax, w )%NONLINFD     approximate the solution of the nonlinear boundary value%             problem%%                   u'' = f ( x, u, u' )%                   alpha(1) u(a) + alpha(2) u'(a) = alpha(3)%                   beta(1)  u(b) + beta(2)  u'(b) = beta(3)%%             using second-order central finite differences; the system%             of nonlinear algebraic equations is solved using Newton's%             method%%%     calling sequences:%             w = nonlinfd ( coeff, a, b, n, alpha, beta, TOL, Nmax, w )%             nonlinfd ( coeff, a, b, n, alpha, beta, TOL, Nmax, w )%%     inputs:%             coeff   string containing name of m-file defining the %                     function f(x,u,u') on the right-hand side of the %                     differential equation; function should take three %                     inputs and return the values of f, the partial%                     of f with respect to u and the partial of f with%                     respect  to u', in that order; i.e., the m-file %                     header should be of the form%                            [f, fu, fup] = coeff ( x, u, up )%             a       left endpoint of problem domain%             b       right endpoint of problem domain%             n       number of uniformly-sized subintervals into which%                     the domain is to be partitioned%             alpha   three-component vector of the coefficients which%                     define the boundary condition at x = a%             beta    three-component vector of the coefficients which%                     define the boundary condition at x = b%             TOL     convergence tolerance for Newton's method; applied%                     to the maximum norm of the difference between%                     successive approximations%             Nmax    maximum number of iterations of Newton's method%                     to be performed to achieve convergence%             w       (optional argument)%                     if present, this vector of length n+1 should%                     contain an approximation to the solution of the%                     boundary value problem to initialize Newton's%                     method%                     if not present, the initial approximation for%                     Newton's method is taken to be the linear function%                     which satisfies the boundary conditions%%     output:%             w       vector of length n+1 containing the approximate%                     values of the solution of the boundary value%                     problem at the locations x = linspace ( a, b, n+1 )%%     dependencies:%             this routine uses the routine TRIDIAGONAL from the "Systems%             of Equations" library%%     NOTE:%             if Newton's method does not converge within the allowed%             number of iterations, then the most recent approximation%             is returned in the vector w%h = ( b - a ) / n;hsq = h*h;hd2 = h/2;x = linspace ( a, b, n+1 );c   = zeros ( 1, n );a   = zeros ( 1, n+1 );b   = zeros ( 1, n );rhs = zeros ( 1, n+1 );%%   initialize w%if ( nargin < 9 ) w = initw ( alpha, beta, x, n+1 ); end; %%   perform Newton's method for systems%for its = 1 : Nmax    if ( alpha(2) == 0 )       a(1) = 1;       rhs(1) = alpha(3) / alpha(1) - w(1);    else       [f fy fyp] = feval ( coeff, x(1), w(1), (alpha(3)-alpha(1)*w(1))/alpha(2) );	   b(1)   = -2;	   rhs(1) = 2*(h*alpha(1)/alpha(2)-1)*w(1) + 2*w(2) - hsq*f - 2*h*alpha(3)/alpha(2);	   if ( alpha(1) == 0 )		   a(1)   = 2 + hsq * fy;	   else	       a(1)   = 2 + hsq * fy - ( 2 + h * fyp ) * h * alpha(1) / alpha(2);       end;    end;    for i = 2:n        [f fy fyp] = feval ( coeff, x(i), w(i), (w(i+1)-w(i-1))/(2*h) );	    c(i-1) = -1 - hd2 * fyp;	    a(i)   = 2 + hsq * fy;	    b(i)   = -1 + hd2 * fyp;	    rhs(i) = w(i-1)-2*w(i)+w(i+1)-hsq * f;    end;    if ( beta(2) == 0 )       a(n+1) = 1;       rhs(n+1) = beta(3) / beta(1) - w(n+1);    else       [f fy fyp] = feval ( coeff, x(n+1), w(n+1), (beta(3)-beta(1)*w(n+1))/beta(2) );       c(n)   = -2;       rhs(n+1) = 2*w(n) - 2*(1+h*beta(1)/beta(2))*w(n+1) - hsq*f + 2*h*beta(3)/beta(2);       if ( beta(1) == 0 )          a(n+1)   = 2 + hsq * fy;       else          a(n+1)   = 2 + hsq * fy + ( 2 - h * fyp ) * h * beta(1) / beta(2);       end;    end;    v = tridiagonal ( c, a, b, rhs );	w = w + v;		if ( max ( abs ( v ) ) < TOL ) return; end;end;disp ( 'Maximum number of iterations exceeded' );function w = initw ( alpha, beta, x, N )if ( alpha(2) == 0 )   if ( beta(2) == 0 )	  A = ( beta(3)/beta(1) - alpha(3)/alpha(1) ) / ( x(N) - x(1) );	  B = alpha(3)/alpha(1) - x(1)*A;	  w = A * x + B;   else      A = ( beta(3) - (alpha(3)/alpha(1)) * beta(1) ) / ( beta(1)*(x(N)-x(1)) + beta(2) );	  B = alpha(3)/alpha(1) - A*x(1);	  w = A * x + B;   end;elseif ( alpha(1) == 0 )   if ( beta(2) == 0 )      A = alpha(3)/alpha(2);	  B = beta(3)/beta(1) - A*x(N);	  w = A * x + B;   elseif ( beta(1) == 0 )      A = ( beta(3)/beta(2) - alpha(3)/alpha(2) ) / ( 2 * ( x(N) - x(1) ) );	  B = beta(3)/beta(2) - 2*A*x(N);	  w = A * x .* x + B * x;   else      A = alpha(3)/alpha(2);	  B = ( beta(3) - A * ( beta(1)*x(N) + beta(2) ) ) / beta(1);	  w = A * x + B;   end;else   if ( beta(2) == 0 )      A = ( alpha(3) - (beta(3)/beta(1)) * alpha(1) ) / ( alpha(1)*(x(1)-x(N)) + alpha(2) );	  B = beta(3)/beta(1) - A*x(N);	  w = A * x + B;   elseif ( beta(1) == 0 )      A = beta(3)/beta(2);	  B = ( alpha(3) - A * ( alpha(1)*x(1) + alpha(2) ) ) / alpha(1);	  w = A * x + B;   else      A = ( alpha(3)*beta(1) - beta(3)*alpha(1) ) / ( alpha(2)*beta(1) - alpha(1)*beta(2) + alpha(1)*beta(1)*(x(1)-x(N)) );	  B = ( alpha(3) - A * ( alpha(1)*x(1) + alpha(2) ) ) / alpha(1);	  w = A * x + B;   end;end;