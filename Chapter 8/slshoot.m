function [lambda, w] = slshoot ( coeff, a, b, n, alpha, beta, TOL, Nmax, numpairs, step )%SLSHOOT      approximate the eigenvalues and the eigenfunctions of the%             proper Sturm - Liouville problem%%                   ( p(x) u' )' + [ q(x) + lambda r(x) ] = 0%                   alpha(1) u(a) + alpha(2) u'(a) = 0%                   beta(1)  u(b) + beta(2)  u'(b) = 0%%             using the shooting method, with the solution of all %             initial value problems approximated using the classical%             4th-order Runge-Kutta method; the eigenvalues are%             approximated using a "bracket and refine" strategy, with%             the Secant method used to control the refine step%%%     calling sequences:%             [lambda, w] = slshoot ( coeff, a, b, n, alpha, beta, TOL, %                                     Nmax, numpairs, step )%             slshoot ( coeff, a, b, n, alpha, beta, TOL, Nmax, numpairs, %                       step )%%     inputs:%             coeff   string containing name of m-file defining the %                     functions p(x), q(x) and r(x) on the right-hand%                     side of the differential equation; function should%                     take a single input and return the values of p, p', q%                     and r, in that order; i.e., the m-file header should%                     be of the form%                            [p, pp, q, r] = coeff ( x )%             a       left endpoint of problem domain%             b       right endpoint of problem domain%             n       number of uniformly-sized steps to take in marching%                     from x = a to x = c %             alpha   two-component vector of the coefficients which%                     define the boundary condition at x = a%             beta    two-component vector of the coefficients which%                     define the boundary condition at x = b %             TOL     convergence tolerance for the Secant method; %             Nmax    maximum number of iterations of the Secant method%                     to be performed to achieve convergence%             numpairs%                     number of eigenpairs to approximate%             step    the increment to be used to bracket each eigenvalue%                     of the Sturm - Liouville problem%%     output:%             lambda  vector containing the approximate eigenvalues%             w       matrix containing the discrete approximations%                     to the eigenfunctions; the i-th column is the %                     eigenfunction corresponding to the i-th entry%                     in the lambda vector%u = zeros ( 2, n+1 );x = linspace ( a, b, n+1 );h = ( b - a ) / n;mu = 0;if ( alpha(2) == 0 )   u(:,1) = [0; 1];elseif ( alpha(1) == 0 )   u(:,1) = [1; 0];else   u(:,1) = [alpha(2); -alpha(1)];end;for pairs = 1 : numpairs    located = 0;    u = shootstep ( coeff, x, h, u, n, mu );    f0 = beta(1) * u(1,n+1) + beta(2) * u(2,n+1);%%   bracket next eigenvalue%    while ( ~located )       mu = mu + step;       u = shootstep ( coeff, x, h, u, n, mu );       f1 = beta(1) * u(1,n+1) + beta(2) * u(2,n+1);       if ( f1 * f0 < 0 )          located = 1;       else          f0 = f1;       end;    end;    s0 = mu - step;    s1 = mu;	iterating = 1;	its = 0;%%   refine eigenvalue approximation using Secant method%    while ( iterating )        si = s1 - f1 * ( s1 - s0 ) / ( f1 - f0 );		    u = shootstep ( coeff, x, h, u, n, si );        fi = beta(1) * u(1,n+1) + beta(2) * u(2,n+1);		its = its + 1;		    if ( ( abs ( fi ) < TOL ) | ( its == Nmax ) )           iterating = 0;	    else	       s0 = s1;   s1 = si;	       f0 = f1;   f1 = fi;	    end;    end;    lambda(pairs) = si;    w(pairs,:) = u(1,:);end;function u = shootstep ( coeff, x, h, u, n, mu ) for i = 1 : n    [p pp q r] = feval ( coeff, x(i) );	k11 = h * [ 0 1; -q-mu*r -pp ] * u(:,i);    k11(2) = k11(2) / p;		[p pp q r] = feval ( coeff, x(i) + h/2 );	k21 = h * [ 0 1; -q-mu*r -pp ] * ( u(:,i) + 0.5*k11 );    k21(2) = k21(2) / p;		k31 = h * [ 0 1; -q-mu*r -pp ] * ( u(:,i) + 0.5*k21 );    k31(2) = k31(2) / p;		[p pp q r] = feval ( coeff, x(i) + h );	k41 = h * [ 0 1; -q-mu*r -pp ] * ( u(:,i) + k31 ) ;    k41(2) = k41(2) / p;	    u(:,i+1) = u(:,i) + ( k11 + 2*k21 + 2*k31 + k41 ) / 6;end;