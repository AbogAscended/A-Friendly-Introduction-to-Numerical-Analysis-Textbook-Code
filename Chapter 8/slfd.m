function [lambda, w] = slfd ( coeff, a, b, n, alpha, beta )%SLFD         approximate the eigenvalues and the eigenfunctions of the%             proper Sturm - Liouville problem%%                   ( p(x) u' )' + [ q(x) + lambda r(x) ] = 0%                   alpha(1) u(a) + alpha(2) u'(a) = 0%                   beta(1)  u(b) + beta(2)  u'(b) = 0%%             using second-order central finite differences%%%     calling sequences:%             [lambda, w] = slfd ( coeff, a, b, n, alpha, beta )%             slfd ( coeff, a, b, n, alpha, beta )%%     inputs:%             coeff   string containing name of m-file defining the %                     functions p(x), q(x) and r(x) on the right-hand%                     side of the differential equation; function should%                     take a single input and return the values of p, p', q%                     and r, in that order; i.e., the m-file header should%                     be of the form%                            [p, pp, q, r] = coeff ( x )%             a       left endpoint of problem domain%             b       right endpoint of problem domain%             n       number of uniformly-sized subintervals into which%                     the domain is to be partitioned; this input also %                     controls the number of eigenpairs to approximate%%                     Dirichlet conditions at a and b:     n-1 eigenpairs%                     Dirichlet condition at a or b:       n eigenpairs%                     Non-Dirichlet conditions at a and b: n+1 eigenpairs%%             alpha   two-component vector of the coefficients which%                     define the boundary condition at x = a%             beta    two-component vector of the coefficients which%                     define the boundary condition at x = b %%     output:%             lambda  vector containing the approximate eigenvalues%             w       matrix containing the discrete approximations%                     to the eigenfunctions; the i-th column is the %                     eigenfunction corresponding to the i-th entry%                     in the lambda vector%%     dependencies:%             this routine uses the routines QRST, QRHESS and INV_POWER %             from the "Eigenvalues" library%h = ( b - a ) / n;hsq = h*h;hd2 = h/2;x = linspace ( a, b, n+1 );c   = zeros ( 1, n );a   = zeros ( 1, n+1 );b   = zeros ( 1, n );%%   load matrix%if ( alpha(2) == 0 )    start = 2;else    start = 1;    [p pp q r] = feval ( coeff, x(1) );	b(1)   = -2 * p / r;	if ( alpha(1) == 0 )		a(1)   = 2 - hsq * q / p;	else	    a(1)   = 2 - hsq * q / p  - ( 2 - h * pp / p ) * h * alpha(1) / alpha(2);    end;	a(1) = ( p / r ) * a(1);end;for i = 2:n    [p pp q r] = feval ( coeff, x(i) );	c(i-1) = ( p / r ) * (-1 + hd2 * pp / p);	a(i)   = ( p / r ) * (2 - hsq * q / p);	b(i)   = ( p / r ) * (-1 - hd2 * pp / p);end;if ( beta(2) == 0 )   endi = n;else   endi = n+1;   [p pp q r] = feval ( coeff, x(n+1) );   c(n)   = -2 * p / r;   if ( beta(1) == 0 )      a(n+1)   = 2 - hsq * q / p;   else      a(n+1)   = 2 - hsq * q / p + ( 2 + h * pp / p ) * h * beta(1) / beta(2);   end;   	a(n+1) = ( p / r ) * a(n+1);end;%%   determine eigenvalues and eigenvectors%cabw = zeros(n+1, endi-start+1);if ( b(start:endi-1) == c(start:endi-1) )   [lambda w(start:endi, :)] = qrst ( a(start:endi), b(start:endi-1), 5e-14, 5*n );   lambda = lambda / hsq;else   A = zeros(n+1,n+1);   for i = start : endi A(i,i) = a(i); end;   for i = start : endi-1 A(i,i+1) = b(i); A(i+1,i) = c(i); end;    lambda = qrhess ( A(start:endi, start:endi), 5e-14, 10*n ) / hsq;   for i = 1 : endi-start+1       [temp  w(start:endi, i)] = inv_power ( A(start:endi, start:endi), lambda(i)*hsq+0.001, rand(1,endi-start+1), 5e-6, 200 );   end;end;