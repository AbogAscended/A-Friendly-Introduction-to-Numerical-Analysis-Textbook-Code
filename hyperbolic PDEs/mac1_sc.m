function [w, exact] = mac1_sc ( a, b, NX, t0, tf, NT, ac, gc, ic, bc )%MAC1_SC      approximate the solution of the one-dimensional advection%             equation%%                    u_t + a(t,x,u) u_x = g(t,x,u)%%             using the MacCormack method%%%     calling sequences:%             w = upwind ( a, b, NX, t0, tf, NT, ac, gc, ic, bc )%             upwind ( a, b, NX, t0, tf, NT, ac, gc, ic, bc )%%     inputs:%             a       left endpoint of space domain%             b       right endpoint of space domain%             NX      number of uniformly-sized subintervals in x-direction%             t0      initial time%             tf      final time%             NT      number of time steps to advance from t = t0 to%                     t = tf%             ac      string containing name of m-file defining the%                     advection coefficient; function should take three%                     inputs and return a single output value%             gc      string containing name of m-file defining the%                     right-hand side function; function should take three%                     inputs and return a single output value%             ic      string containing name of m-file defining the %                     initial conditions; function should take %                     one input and return the initial value of the solution %             bc      string containing name of m-file defining the %                     Dirichlet boundary conditions; function should take %                     one input and return a single output value%%     output:%             w       vector of length NX+1 containing the approximate %                     values of the solution of the advection equation%x = linspace ( a, b, NX+1 );dx = ( b - a ) / NX;t = linspace ( t0, tf, NT+1 );dt = ( tf - t0 ) / NT;wold = zeros ( 1, NX+1 );wstar = zeros ( 1, NX+1 );wnew = zeros ( 1, NX+1 );for j = 1 : NX+1    wold(j) = feval ( ic, x(j) );end;%wold(NX+1) = 1;for n = 1 : NT    for j = 1 : NX        ajn = feval ( ac, t(n), x(j), wold(j) );	    gjn = feval ( gc, t(n), x(j), wold(j) );		lambda = ajn * dt / dx;		wstar(j) = ( 1 + lambda ) * wold(j) - lambda * wold(j+1) + dt * gjn;	end;%	wstar(1) = 1;		for j = 2 : NX        ajs = feval ( ac, t(n+1), x(j), wstar(j) );	    gjs = feval ( gc, t(n+1), x(j), wstar(j) );		lambda = ajs * dt / dx;		wnew(j) = 0.5 * ( wold(j) + wstar(j) - lambda * ( wstar(j) - wstar(j-1) ) + dt * gjs );	end;%	wnew(NX+1) = exp(2*t(n+1)) / ( 1 + exp(t(n+1)) );	wold(2:NX+1) = wnew(2:NX+1);end;w = wold;exact = zeros ( 1, NX + 1 );for j = 1 : NX+1    exact(j) = ic ( x(j) - tf / ( 1 + x(j)^2 ) );end;function y = ic ( x )if ( ( 0.5 <= x ) & ( x <= 1 ) )   y = 1;else   y = 0;end;function y = bc4 ( t ) %if ( t < 1 )   y = 1;%else%   y = 0;%end;