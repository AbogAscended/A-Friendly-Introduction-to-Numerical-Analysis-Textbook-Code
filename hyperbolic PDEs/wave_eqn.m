function w = wave_eqn ( a, b, NX, t0, tf, NT, cm2, bc, ic )%WAVE_EQN     approximate the solution of the one-dimensional wave equation%%                    u_tt = c^2 u_xx%%             using the finite difference method with second-order central%             differencing in both time and space%%%     calling sequences:%             w = wave_eqn ( a, b, NX, t0, tf, NT, cm2, bc, ic )%             wave_eqn ( a, b, NX, t0, tf, NT, cm2, bc, ic )%%     inputs:%             a       left endpoint of space domain%             b       right endpoint of space domain%             NX      number of uniformly-sized subintervals in x-direction%             t0      initial time%             tf      final time%             NT      number of time steps to advance from t = t0 to%                     t = tf%             cm2     wave speed coefficient, c^2%             bc      string containing name of m-file defining the %                     Dirichlet boundary conditions; function should take %                     one input and return a two component array containing%                     the boundary value at the left endpoint and the%                     boundary value at the right endpoint, in that order%             ic      string containing name of m-file defining the %                     initial conditions; function should take %                     one input and return a two component array containing%                     the initial value of the solution and the initial%                     value of the time derivative of the solution, in %                     that order%%     output:%             w       vector of length NX+1 containing the approximate %                     values of the solution of the wave equation%x = linspace ( a, b, NX+1 );dx = (b-a)/NX;t = linspace ( t0, tf, NT+1 );dt = (tf-t0)/NT;lambda = (dt/dx)^2 * cm2;wolder = zeros ( 1, NX+1 );wold   = zeros ( 1, NX+1 );wnew   = zeros ( 1, NX+1 );g      = zeros ( 1, NX+1 );%%   load initial and boundary conditions for first time step%for j = 2 : NX    [wolder(j), g(j)] = feval ( ic, x(j) );end;[wolder(1), wolder(NX+1)] = feval ( bc, t0 );%%   perform first time step%for j = 2 : NX    wnew(j) = 0.5*lambda*( wolder(j-1) + wolder(j+1) ) + ( 1 - lambda ) * wolder(j) + dt * g(j);end;wold(2:NX) = wnew(2:NX);[wold(1), wold(NX+1)] = feval ( bc, t0+dt );%%   perform remaining time steps% if ( NT > 1 )   for n = 2 : NT       for j = 2 : NX           wnew(j) = lambda*( wold(j-1) + wold(j+1) ) + 2*( 1 - lambda ) * wold(j) - wolder(j);	   end;       wolder = wold;        wold(2:NX) = wnew(2:NX);       [wold(1), wold(NX+1)] = feval ( bc, t(n+1) );   end;end;w = wold;